(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var _objectAssign = require('./_objectAssign');

module.exports =
  typeof Object.assign === 'function' ? Object.assign : _objectAssign;

},{"./_objectAssign":6}],2:[function(require,module,exports){
var _isPlaceholder = require('./_isPlaceholder');


/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

},{"./_isPlaceholder":5}],3:[function(require,module,exports){
var _curry1 = require('./_curry1');
var _isPlaceholder = require('./_isPlaceholder');


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2
             : _curry1(function(_b) { return fn(a, _b); });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2
             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })
             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })
             : fn(a, b);
    }
  };
};

},{"./_curry1":2,"./_isPlaceholder":5}],4:[function(require,module,exports){
module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

},{}],5:[function(require,module,exports){
module.exports = function _isPlaceholder(a) {
  return a != null &&
         typeof a === 'object' &&
         a['@@functional/placeholder'] === true;
};

},{}],6:[function(require,module,exports){
var _has = require('./_has');

// Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
module.exports = function _objectAssign(target) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  var idx = 1;
  var length = arguments.length;
  while (idx < length) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
};

},{"./_has":4}],7:[function(require,module,exports){
var _assign = require('./internal/_assign');
var _curry2 = require('./internal/_curry2');


/**
 * Create a new object with the own properties of the first object merged with
 * the own properties of the second object. If a key exists in both objects,
 * the value from the second object will be used.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> {k: v} -> {k: v}
 * @param {Object} l
 * @param {Object} r
 * @return {Object}
 * @see R.mergeWith, R.mergeWithKey
 * @example
 *
 *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
 *      //=> { 'name': 'fred', 'age': 40 }
 *
 *      var resetToDefault = R.merge(R.__, {x: 0});
 *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
 */
module.exports = _curry2(function merge(l, r) {
  return _assign({}, l, r);
});

},{"./internal/_assign":1,"./internal/_curry2":3}],8:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns a partial copy of an object containing only the keys specified. If
 * the key does not exist, the property is ignored.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig [k] -> {k: v} -> {k: v}
 * @param {Array} names an array of String property names to copy onto a new object
 * @param {Object} obj The object to copy from
 * @return {Object} A new object with only properties from `names` on it.
 * @see R.omit, R.props
 * @example
 *
 *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
 *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
 */
module.exports = _curry2(function pick(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});

},{"./internal/_curry2":3}],9:[function(require,module,exports){
/*! https://mths.be/includes v0.2.0 by @mathias */
if (!String.prototype.includes) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var toString = {}.toString;
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var indexOf = ''.indexOf;
		var includes = function(search) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			if (search && toString.call(search) == '[object RegExp]') {
				throw TypeError();
			}
			var stringLength = string.length;
			var searchString = String(search);
			var searchLength = searchString.length;
			var position = arguments.length > 1 ? arguments[1] : undefined;
			// `ToInteger`
			var pos = position ? Number(position) : 0;
			if (pos != pos) { // better `isNaN`
				pos = 0;
			}
			var start = Math.min(Math.max(pos, 0), stringLength);
			// Avoid the `indexOf` call if no match is possible
			if (searchLength + start > stringLength) {
				return false;
			}
			return indexOf.call(string, searchString, pos) != -1;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'includes', {
				'value': includes,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.includes = includes;
		}
	}());
}

},{}],10:[function(require,module,exports){
/*! http://mths.be/startswith v0.2.0 by @mathias */
if (!String.prototype.startsWith) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var toString = {}.toString;
		var startsWith = function(search) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			if (search && toString.call(search) == '[object RegExp]') {
				throw TypeError();
			}
			var stringLength = string.length;
			var searchString = String(search);
			var searchLength = searchString.length;
			var position = arguments.length > 1 ? arguments[1] : undefined;
			// `ToInteger`
			var pos = position ? Number(position) : 0;
			if (pos != pos) { // better `isNaN`
				pos = 0;
			}
			var start = Math.min(Math.max(pos, 0), stringLength);
			// Avoid the `indexOf` call if no match is possible
			if (searchLength + start > stringLength) {
				return false;
			}
			var index = -1;
			while (++index < searchLength) {
				if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
					return false;
				}
			}
			return true;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'startsWith', {
				'value': startsWith,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.startsWith = startsWith;
		}
	}());
}

},{}],11:[function(require,module,exports){
window.bashEmulator = require('./index')

},{"./index":16}],12:[function(require,module,exports){
function cd (env, args) {
  env.system.state.workingDirectory = args[0]
  env.exit()
}

module.exports = cd


},{}],13:[function(require,module,exports){
var commands = {
  ls: require('./ls'),
  pwd: require('./pwd'),
  cd: require('./cd')
}

module.exports = commands

},{"./cd":12,"./ls":14,"./pwd":15}],14:[function(require,module,exports){
require('string.prototype.startswith')
require('string.prototype.includes')

function ls (env, args) {
  var state = env.system.state
  var cwd = state.workingDirectory
  var listing = Object.keys(state.fileSystem)
    .filter(function (path) {
      return (
        path.startsWith(cwd) &&
        !path.substr(cwd.length).includes('/') &&
        path !== cwd
      )
    })
    .map(function (path) {
      return path.substr(cwd.length)
    })
  env.output(listing.join(' '))
  env.exit()
}

module.exports = ls

},{"string.prototype.includes":9,"string.prototype.startswith":10}],15:[function(require,module,exports){
function pwd (env, args) {
  env.output(env.system.state.workingDirectory)
  env.exit()
}

module.exports = pwd


},{}],16:[function(require,module,exports){
var pick = require('ramda/src/pick')
var merge = require('ramda/src/merge')
var commands = require('./commands')

function bashEmulator (initialState) {
  var state = createState(initialState)
  var emulator = {
    commands: commands,
    state: state,
    run: function (input) {
      var args = input.split(' ')
      var cmd = args.shift()
      if (!commands[cmd]) {
        return Promise.reject('not implemented yet')
      }
      return new Promise(function (resolve) {
        commands[cmd]({
          output: resolve,
          exit: resolve,
          system: emulator
        }, args)
      })
    },
    getDir: function () {
      return Promise.resolve(state.workingDirectory)
    },
    changeDir: function (path) {
      state.workingDirectory = path
      return Promise.resolve()
    },
    read: function (filePath) {
      return Promise.resolve(state.fileSystem[filePath].content)
    },
    readDir: function (path) {
      // TODO:
      // - `readDir(path) -> Promise([files])`
      //   - `path` optional, relative path of directory to read. Defaults to current directory.
      //   - Returns a Promise that resolves with an array listing all content of the directory
    },
    getStats: function (path) {
      return Promise.resolve(state.fileSystem[path].meta)
    },
    createDir: function (path) {
      // TODO:
      // - `createDir(path) -> Promise`
      //   - `path` relative, non-existed path for new directory
      //   - Returns a Promise that resolves when directory is created
    },
    write: function (filePath, content) {
      // TODO:
      // - `write(filePath) -> Promise`
      //   - If file isn't empty, content is appended to it.
      //   - `filePath` path of file that should be written to. File doesn't have to exist.
      //   - Returns a Promise that resolves when writing is done
    },
    remove: function (path) {
      delete state.fileSystem[path]
      return Promise.resolve()
    },
    getHistory: function () {
      return Promise.resolve(state.history)
    }
  }
  return emulator
}

function createState (initialState) {
  var state = defaultState()
  return merge(state, pick(Object.keys(state), initialState || {}))
}

function defaultState () {
  return {
    history: [],
    fileSystem: {
      '/': {
        type: 'dir',
        lastEdited: Date.now()
      },
      '/home': {
        type: 'dir',
        lastEdited: Date.now()
      },
      '/home/username': {
        type: 'dir',
        lastEdited: Date.now()
      }
    },
    workingDirectory: '/home/username'
  }
}

module.exports = bashEmulator

},{"./commands":13,"ramda/src/merge":7,"ramda/src/pick":8}]},{},[11]);
